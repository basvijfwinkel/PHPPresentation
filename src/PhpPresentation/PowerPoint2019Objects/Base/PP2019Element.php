<?php


// TODO : collect all parsing errors within all child objects and attribute errors




/**
 * This file is part of PHPPresentation - A pure PHP library for reading and writing
 * presentations documents.
 *
 * PHPPresentation is free software distributed under the terms of the GNU Lesser
 * General Public License version 3 as published by the Free Software Foundation.
 *
 * For the full copyright and license information, please read the LICENSE
 * file that was distributed with this source code. For the full list of
 * contributors, visit https://github.com/PHPOffice/PHPPresentation/contributors.
 *
 * @see        https://github.com/PHPOffice/PHPPresentation
 *
 * @license     http://www.gnu.org/licenses/lgpl.txt LGPL version 3
 */

declare(strict_types=1);

namespace PhpOffice\PhpPresentation\PowerPoint2019Objects\Base;;

use Exception;
use DomElement;
use BadMethodCallException;

use PhpOffice\Common\XMLReader;
use PhpOffice\Common\XMLWriter;

use PhpOffice\PhpPresentation\PowerPoint2019Objects\Debug\ParseHelper;

/**
 * PP2019Element class
 */
class PP2019Element extends ParseHelper
{

    protected $elementName = null;
    protected $elementNamespace = null;
    protected $namespacedElementName = null; // will be autogenerated

    // defined namespaces for this element
    protected $namespaces = [];

    // attributes
    protected $attributes = [];
    protected $knownAttributes = [];

    // child elements
    protected $childNodes = [];
    protected $knownChildNodes = [];
    protected $childNodeDefaultNamespace = null;

    // mappings from classnames to namespaced classnames
    protected $namespacedClassnames = [
                                       'ViewProps'       => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\ViewProps',
                                       'NormalViewPr'    => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\NormalViewPr',
                                       'RestoredLeft'    => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\RestoredLeft',
                                       'RestoredTop'     => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\RestoredTop',
                                       'CSldViewPr'      => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\CSldViewPr',
                                       'CViewPr'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\CViewPr',
                                       'SlideViewPr'     => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\SlideViewPr',
                                       'Scale'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\Scale',
                                       'Origin'          => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\Origin',
                                       'Sx'              => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\Sx',
                                       'Sy'              => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\Sy',
                                       'GuideLst'        => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\GuideLst',
                                       'GridSpacing'     => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\GridSpacing',
                                       'OutlineViewPr'   => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\OutlineViewPr',
                                       'NotesTextViewPr' => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\NotesTextViewPr',
                                      ];

    public const VIEW_HANDOUT         = 'handoutView';
    public const VIEW_NOTES           = 'notesView';
    public const VIEW_NOTES_MASTER    = 'notesMasterView';
    public const VIEW_OUTLINE         = 'outlineView';
    public const VIEW_SLIDE           = 'sldView';
    public const VIEW_SLIDE_MASTER    = 'sldMasterView';
    public const VIEW_SLIDE_SORTER    = 'sldSorterView';
    public const VIEW_SLIDE_THUMBNAIL = 'sldThumbnailView';

    protected $enumValidations = [
                   'ViewPropsLastView' => [
                                           self::VIEW_HANDOUT,
                                           self::VIEW_NOTES,
                                           self::VIEW_NOTES_MASTER,
                                           self::VIEW_OUTLINE,
                                           self::VIEW_SLIDE,
                                           self::VIEW_SLIDE_MASTER,
                                           self::VIEW_SLIDE_SORTER,
                                           self::VIEW_SLIDE_THUMBNAIL,
                                          ]
                                 ];


    function __construct()
    {
        // prepare the namespaced names

        // namespaced elementName
        $this->namespacedElementName = (is_null($this->elementNamespace)?'':($this->elementNamespace.':')).$this->elementName;

        // attributes namespaced names
        foreach($this->knownAttributes as $attrName => $attrDef)
        {
            if (!is_null($attrDef['ns']??null))
            {
                // use namespace from definition
                $this->knownAttributes[$attrName]['namespacedName'] = $attrDef['ns'].':'.$attrName;
            }
            else
            {
                // no namespace
                $this->knownAttributes[$attrName]['namespacedName'] = $attrName;
            }
        }

        // childNodes namespace names
        foreach($this->knownChildNodes as $childNodeName => $childNodeDef)
        {
            if (!is_null($childNodeDef['ns']??null))
            {
                // use namespace from element definition
                $this->knownChildNodes[$childNodeName]['namespacedName'] = $childNodeDef['ns'].':'.$childNodeName;
            }
            elseif (!is_null($this->childNodeDefaultNamespace))
            {
                // use default childnode namespace
                $this->knownChildNodes[$childNodeName]['namespacedName'] = $this->childNodeDefaultNamespace.':'.$childNodeName;
            }
            else
            {
                // no namespace
                $this->knownChildNodes[$childNodeName]['namespacedName'] = $childNodeName;
            }
        }
    }

    // this is for top elements which get the xml data in a string
    public function loadFromXMLString(string $xmlstring): bool
    {
       // clear out all previous settings
       $this->clearDefaultSettings();

       $xmlReader = new XMLReader();
       $dom = $xmlReader->getDomFromString($xmlstring);
       if ($dom)
       {
            $element = $this->getElementFromDom($xmlReader, $this->namespacedElementName);
            // check if the element exists in the dom that we were given
            if ($element)
            {
                // get attributes
                $this->parseAttributes($element);

                // get children
                $this->parseChildNodes($element);

                // get namespaces
                $this->parseNameSpaces($xmlstring);
            }
            else
            {
                // the top element does not seem to exist in the xmlstring we were given
                $this->setOwnParsingError("The top level element ".$this->namespacedElementName." does not seem to exist in the xml document we received");
            }
        }
        return $this->hasParsingErrors;
    }

    public function loadFromDomElement(DomElement $element): bool
    {
        // get attributes
        $this->parseAttributes($element);

        // get children
        $this->parseChildNodes($element);

        // get namespaces
//        $this->parseNameSpaces($xmlstring);

        return $this->hasParsingErrors;
    }

    // clear out all settings
    public function clearDefaultSettings(): void
    {
        $this->namespaces = [];
        $this->attributes = [];
        $this->childNodes = [];

        $this->hasParsingErrors = false;
    }

    // get all namespaces
    protected function parseNameSpaces(string $xmlstring): void
    {
        $this->namespaces = $this->extractNamespaces($xmlstring);
    }

    // get all attributes for the specified element
    protected function parseAttributes(DOMElement $element): void
    {
        $allAttributes = $this->getAllAttributes($element, $this->namespacedElementName);

        foreach($this->knownAttributes as $attrName => $attrDef)
        {
            if (isset($allAttributes[$attrDef['namespacedName']]))
            {
                // set the attribute value
// TODO : validate the attribute ?
                $this->attributes[$attrName] = $allAttributes[$attrDef['namespacedName']];
            }
            else
            {
                // attribute was not present : set to null
                $this->attributes[$attrName] = null;
            }
        }

        // also report if we missed some attribute (sets hasParsingErrors flag to true)
        $this->reportUnknownAttributes($this->knownAttributes, array_keys($allAttributes));
    }

    protected function parseChildNodes(DOMElement $element): void
    {
        $allChildNodes = $this->getAllChildNodes($element, $this->namespacedElementName);
//$this->e($allChildNodes);
        // collect all known childNodes
        foreach($this->knownChildNodes as $childNodeName => $childNodeDef)
        {
//$this->e($childNodeDef);exit;
            if (isset($allChildNodes[$childNodeDef['namespacedName']]))
            {
// TODO : somehow get a list for namespaces for all classes

                $classname = $childNodeDef['type'];
                $namespacedClassname = $this->namespacedClassnames[$classname]??null;
                if (is_null($namespacedClassname))
                {
                    throw new Exception("Add '".$classname."' namespace to namespaceClassname array in PP2019Element");
                }

                $this->childNodes[$childNodeName] = new $namespacedClassname;
                $childParsingErrors = $this->childNodes[$childNodeName]->loadFromDomElement($allChildNodes[$childNodeDef['namespacedName']]);
                // see if we got some parsing error in the childNode
                if ($childParsingErrors)
                {
                    $this->hasParsingErrors = true;
                    // get the parsing errors from the childNode
                    $this->debugParseErrorChildNodes[] = $this->childNodes[$childNodeName]->getParsingErrors();
                }
            }
            else
            {
                //not present
                $this->childNodes[$childNodeName] = null;
            }
        }

        // also report if we missed some ChildNode
        $this->reportUnknownChildNodes($this->knownChildNodes, array_keys($allChildNodes));
    }

    public function __call(string $methodName , array $methodArguments ) : mixed
    {
        // get or set method?
        if (substr($methodName,0,3) == 'get')
        {
            $name = lcfirst(substr($methodName,3));
            // getter for a known attribute?
            foreach(array_keys($this->knownAttributes) as $attrName)
            {
                if ($attrName == $name)
                {
                    // this is a known attribute : return the value or null
                    return ($this->attributes[$attrName]??null);
                }
            }

            // getter for a known childNode?
            foreach(array_keys($this->knownChildNodes) as $nodeName)
            {
                if ($nodeName == $name)
                {
                    // this is a known childNode : return the object or null
                    return ($this->childNodes[$nodeName]??null);
                }
            }

            // if we end up here : no match
        }
        elseif (substr($methodName,0,3) == 'set')
        {
            // do we have a set method with only 1 argument?
            if (count($methodArguments) == 1)
            {
                $name = lcfirst(substr($methodName,3));
                foreach(array_keys($this->knownAttributes) as $attrName)
                {
                    if ($attrName == $name)
                    {
                        // this is a known attribute : set it if input is valid
                        $this->validateAttributeValue($attrName, $methodName, $methodArguments[0]); // throws an exception on a validation failure

                        $this->attributes[$attrName] = $methodArguments[0];
                    }
                }
                foreach(array_keys($this->knownChildNodes) as $nodeName)
                {
                    if ($nodeName == $name)
                    {
                        // this is a known childNode : set it if input is valid
                        $this->validateChildNodeObject($nodeName, $methodName, $methodArguments[0]);
                        $this->childNodes[$nodeName] = $methodArguments[0];
                    }
                }
            }
       }

       // we could not process the method : return the standard error
       throw new BadMethodCallException("Unknown method ".$methodName);
    }

    protected function validateChildNodeObject(string $childNodeName, string $methodName, mixed $object): mixed
    {
        // does the child node exist
        if (isset($this->knownChildNodes[$childNodeName]))
        {
            // is the object the right type?
            if (get_class($object) != $this->knownChildNodes[$childNodeName]['type'])
            {
                $errMsg = $methodName." : expected an object ".$this->knownChildNodes[$childNodeName]['type']." but received an ".get_class($object)." object.";
                throw new Exception($errMsg);
            }
        }
        else
        {
            // wrong object type was given
            $errMsg = $methodName." tries to set an unknown child node '".$childNodeName."'";
            throw new Exception($errMsg);
        }
    }

    protected function validateAttributeValue(string $attrName, string $methodName, mixed $value): void
    {
        $errMsg = false;
        $attrDef = $this->knownAttributes[$attrName];
        $attrDefType = $attrDef['type'];
        if ($attrDefType == 'integer')
        {
            // integer
            if (!is_numeric($value))
            {
                $errMsg = $methodName." needs to provide and integer. ".var_export($value,1);
            }
        }
        elseif ($attrDefType == 'enum')
        {
            $enumType = $attrDef['enumType'];
            // enum
            if (isset($this->enumValidations[$enumType]))
            {
                if (!in_array($value,$this->enumValidations[$enumType]))
                {
                    $errMsg = "Unknown enum value '".$value."' for enumType '".$enumType."'. Please add it to the enumType values";
                }
            }
            else
            {
                $errMsg = "Missing enumType '".$enumType."' in this->enumValidations in PP2019Elements. Please add it at the top of the class";
            }
        }
        else
        {
            // unhandled type
        }

        // in case we have an error : throw an exception
        if ($errMsg !== false)
        {
            throw new Exception($errMsg);
        }
    }

    public function writeToXML(XMLWriter $objWriter): void
    {
        // start element
        $objWriter->startElement($this->namespacedElementName);

        // do we have namespaces?
        if ($this->namespaces != [])
        {
            foreach($this->namespaces as $namespace => $url)
            {
                $objWriter->writeAttribute('xmlns:'.$namespace, $url);
            }
        }

        // do we have attributes?
        if ($this->attributes != [])
        {
$this->e($this->attributes);
            foreach($this->attributes as $attrName => $attrValue)
            {
                if (is_null($attrValue)) { continue; }
$this->e($attrName."=".$attrValue);
                $objWriter->writeAttribute($this->knownAttributes[$attrName]['namespacedName'], $attrValue);
            }
        }

        // do we have child nodes?
        if ($this->childNodes != [])
        {
            foreach($this->childNodes as $childNode)
            {
                $childNode->writeToXML($objWriter);
            }
        }

        // end element
        $objWriter->endElement();
    }

}