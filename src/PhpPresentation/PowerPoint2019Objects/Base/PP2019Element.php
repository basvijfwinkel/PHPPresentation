<?php


// TODO : collect all parsing errors within all child objects and attribute errors




/**
 * This file is part of PHPPresentation - A pure PHP library for reading and writing
 * presentations documents.
 *
 * PHPPresentation is free software distributed under the terms of the GNU Lesser
 * General Public License version 3 as published by the Free Software Foundation.
 *
 * For the full copyright and license information, please read the LICENSE
 * file that was distributed with this source code. For the full list of
 * contributors, visit https://github.com/PHPOffice/PHPPresentation/contributors.
 *
 * @see        https://github.com/PHPOffice/PHPPresentation
 *
 * @license     http://www.gnu.org/licenses/lgpl.txt LGPL version 3
 */

declare(strict_types=1);

namespace PhpOffice\PhpPresentation\PowerPoint2019Objects\Base;;

use Exception;
use DomElement;
use DomDocument; // for debugging
use BadMethodCallException;

use PhpOffice\Common\XMLReader;
use PhpOffice\Common\XMLWriter;

use PhpOffice\PhpPresentation\PowerPoint2019Objects\Debug\ParseHelper;

/**
 * PP2019Element class
 */
class PP2019Element extends ParseHelper
{

    protected $elementName = null;
    protected $elementNamespace = null;
    protected $namespacedElementName = null; // will be autogenerated

    // defined namespaces for this element
    protected $namespaces = [];

    // attributes
    protected $attributes = [];
    protected $knownAttributes = [];

    // child elements
    protected $childNodes = [];
    protected $knownChildNodes = [];
    protected $childNodeDefaultNamespace = null;

    // mappings from classnames to namespaced classnames
    protected $namespacedClassnames = [
                                       // viewProps
                                       'ViewProps'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\ViewProps',
                                       'NormalViewPr'      => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\NormalViewPr',
                                       'RestoredLeft'      => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\RestoredLeft',
                                       'RestoredTop'       => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\RestoredTop',
                                       'CSldViewPr'        => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\CSldViewPr',
                                       'CViewPr'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\CViewPr',
                                       'SlideViewPr'       => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\SlideViewPr',
                                       'Scale'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\Scale',
                                       'Origin'            => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\Origin',
                                       'Sx'                => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\Sx',
                                       'Sy'                => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\Sy',
                                       'GuideLst'          => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\GuideLst',
                                       'GridSpacing'       => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\GridSpacing',
                                       'OutlineViewPr'     => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\OutlineViewPr',
                                       'NotesTextViewPr'   => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\viewProps\NotesTextViewPr',
                                       // theme
                                       'Accent1'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Accent1',
                                       'Accent2'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Accent2',
                                       'Accent3'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Accent3',
                                       'Accent4'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Accent4',
                                       'Accent5'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Accent5',
                                       'Accent6'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Accent6',
                                       'Alpha'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Alpha',
                                       'BgFillStyleLst'    => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\BgFillStyleLst',
                                       'BodyPr'            => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\BodyPr',
                                       'ClrScheme'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\ClrScheme',
                                       'Cs'                => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Cs',
                                       'Dk1'               => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Dk1',
                                       'Dk2'               => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Dk2',
                                       'Ea'                => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Ea',
                                       'EffectLst'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\EffectLst',
                                       'EffectRef'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\EffectRef',
                                       'EffectStyleLst'    => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\EffectStyleLst',
                                       'EffectStyle'       => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\EffectStyle',
                                       'ExtLst'            => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\ExtLst',
                                       'Ext'               => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Ext',
                                       'ExtraClrSchemeLst' => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\ExtraClrSchemeLst',
                                       'FillRef'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\FillRef',
                                       'FillStyleLst'      => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\FillStyleLst',
                                       'FmtScheme'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\FmtScheme',
                                       'FolHlink'          => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\FolHlink',
                                       'Font'              => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Font',
                                       'FontRef'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\FontRef',
                                       'FontScheme'        => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\FontScheme',
                                       'GradFill'          => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\GradFill',
                                       'GsLst'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\GsLst',
                                       'Gs'                => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Gs',
                                       'Hlink'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Hlink',
                                       'Latin'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Latin',
                                       'Lin'               => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Lin',
                                       'LnDef'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\LnDef',
                                       'Ln'                => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Ln',
                                       'LnRef'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\LnRef',
                                       'LnStyleLst'        => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\LnStyleLst',
                                       'LstStyle'          => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\LstStyle',
                                       'Lt1'               => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Lt1',
                                       'Lt2'               => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Lt2',
                                       'LumMod'            => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\LumMod',
                                       'MajorFont'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\MajorFont',
                                       'MinorFont'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\MinorFont',
                                       'Miter'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Miter',
                                       'ObjectDefaults'    => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\ObjectDefaults',
                                       'OuterShdw'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\OuterShdw',
                                       'PrstDash'          => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\PrstDash',
                                       'SatMod'            => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\SatMod',
                                       'SchemeClr'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\SchemeClr',
                                       'Shade'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Shade',
                                       'SolidFill'         => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\SolidFill',
                                       'SysClr'            => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\SysClr',
                                       'SrgbClr'           => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\SrgbClr',
                                       'SpPr'              => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\SpPr',
                                       'Style'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Style',
                                       'ThemeElements'     => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\ThemeElements',
                                       'ThemeFamily'       => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\ThemeFamily',
                                       'Theme'             => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Theme',
                                       'Tint'              => 'PhpOffice\PhpPresentation\PowerPoint2019Objects\theme\Tint',
                                      ];

    public const VIEW_HANDOUT         = 'handoutView';
    public const VIEW_NOTES           = 'notesView';
    public const VIEW_NOTES_MASTER    = 'notesMasterView';
    public const VIEW_OUTLINE         = 'outlineView';
    public const VIEW_SLIDE           = 'sldView';
    public const VIEW_SLIDE_MASTER    = 'sldMasterView';
    public const VIEW_SLIDE_SORTER    = 'sldSorterView';
    public const VIEW_SLIDE_THUMBNAIL = 'sldThumbnailView';

    protected $enumValidations = [
                   'ViewPropsLastView' => [
                                           self::VIEW_HANDOUT,
                                           self::VIEW_NOTES,
                                           self::VIEW_NOTES_MASTER,
                                           self::VIEW_OUTLINE,
                                           self::VIEW_SLIDE,
                                           self::VIEW_SLIDE_MASTER,
                                           self::VIEW_SLIDE_SORTER,
                                           self::VIEW_SLIDE_THUMBNAIL,
                                          ]
                                 ];


    function __construct()
    {
        // =========== prepare the namespaced names

        // prepare namespaced elementName
        $this->namespacedElementName = (is_null($this->elementNamespace)?'':($this->elementNamespace.':')).$this->elementName;

        // prepare attributes namespaced names
        foreach($this->knownAttributes as $attrName => $attrDef)
        {
            if (!is_null($attrDef['ns']??null))
            {
                // use namespace from definition
                $this->knownAttributes[$attrName]['namespacedName'] = $attrDef['ns'].':'.$attrName;
            }
            else
            {
                // no namespace
                $this->knownAttributes[$attrName]['namespacedName'] = $attrName;
            }
        }

        // prepare childNodes namespace names
        foreach($this->knownChildNodes as $childNodeName => $childNodeDef)
        {
            if (!is_null($childNodeDef['ns']??null))
            {
                // use namespace from element definition
                $this->knownChildNodes[$childNodeName]['namespacedName'] = $childNodeDef['ns'].':'.$childNodeName;
            }
            elseif (!is_null($this->childNodeDefaultNamespace))
            {
                // use default childnode namespace
                $this->knownChildNodes[$childNodeName]['namespacedName'] = $this->childNodeDefaultNamespace.':'.$childNodeName;
            }
            else
            {
                // no namespace
                $this->knownChildNodes[$childNodeName]['namespacedName'] = $childNodeName;
            }
        }
    }

    // this is for top elements which get the xml data in a string
    public function loadFromXMLString(string $xmlstring): bool
    {
       // clear out all previous settings
       $this->clearDefaultSettings();

       $xmlReader = new XMLReader();
       $dom = $xmlReader->getDomFromString($xmlstring);
       if ($dom)
       {
            $element = $this->getElementFromDom($xmlReader, $this->namespacedElementName);
            // check if the element exists in the dom that we were given
            if ($element)
            {
                // get attributes
                $this->parseAttributes($element);

                // get children
                $this->parseChildNodes($element);

                // get namespaces
                $this->parseNameSpaces($element);
            }
            else
            {
                // the top element does not seem to exist in the xmlstring we were given
                $this->setOwnParsingError("The top level element ".$this->namespacedElementName." does not seem to exist in the xml document we received");
            }
        }
        return $this->hasParsingErrors;
    }

    public function loadFromDomElement(DomElement $element): bool
    {
        // get attributes
        $this->parseAttributes($element);

        // get children
        $this->parseChildNodes($element);

        // get namespaces
        $this->parseNameSpaces($element);

        return $this->hasParsingErrors;
    }

    // clear out all settings
    public function clearDefaultSettings(): void
    {
        $this->namespaces = [];
        $this->attributes = [];
        $this->childNodes = [];

        $this->hasParsingErrors = false;
    }

    // get all namespaces
    protected function parseNameSpaces(DomElement $element): void
    {
        $this->namespaces = $this->extractNamespaces($element);
    }

    // get all attributes for the specified element
    protected function parseAttributes(DOMElement $element): void
    {
        $allAttributes = $this->getAllAttributes($element, $this->namespacedElementName);

        foreach($allAttributes as $attrName => $attrProps)
        {
            foreach($this->knownAttributes as $knownAttrName => $knownAttrDef)
            {
                if ($attrName == $knownAttrName)
                {
                    // found a known attribute
                    $this->attributes[$attrName] = $attrProps;//$allAttributes[$knownAttrDef['namespacedName']];
                }
            }
        }

        // set missing attributes to null
        foreach($this->knownAttributes as $knownAttrName => $knownAttrDef)
        {
            if (!isset($allAttributes[$knownAttrDef['namespacedName']]))
            {
                // attribute was not present : set to null
                $this->attributes[$knownAttrName] = null;
            }
        }

        // also report if we missed some attribute (sets hasParsingErrors flag to true)
        $this->reportUnknownAttributes($this->knownAttributes, array_keys($allAttributes));
    }

    protected function parseChildNodes(DOMElement $element): void
    {
        $allChildNodes = $this->getAllChildNodes($element, $this->namespacedElementName);

        // collect all known childNodes
        foreach($allChildNodes as $allChildNode)
        {
            foreach($this->knownChildNodes as $knownChildNodeName => $knownChildNodeDef)
            {
                if ($allChildNode['name'] == $knownChildNodeDef['namespacedName'])
                {
                    // found a known child node
                    $classname = $knownChildNodeDef['type'];
                    $namespacedClassname = $this->namespacedClassnames[$classname]??null;
                    if (is_null($namespacedClassname))
                    {
                        throw new Exception("Add '".$classname."' namespace to namespaceClassname array in PP2019Element. Called from ".$element->tagName."    ");
                    }

                    $obj = new $namespacedClassname;
                    $childParsingErrors = $obj->loadFromDomElement($allChildNode['data']);

                     // see if we got some parsing error in the childNode
                    if ($childParsingErrors)
                    {
                        $this->hasParsingErrors = true;
                        // get the parsing errors from the childNode
                        $this->debugParseErrorChildNodes[] = $obj->getParsingErrors();
                    }
                    else
                    {
                        // no parsing errors
                        $this->childNodes[] = ['name' => $knownChildNodeName, 'data' => $obj];
                    }
                }
            }
        }

        // set missing childNodes to null
        foreach($this->knownChildNodes as $knownChildNodeName => $knownChildNodeDef)
        {
            foreach($allChildNodes as $allChildNode)
            {

                if ($allChildNode['name'] == $knownChildNodeDef['namespacedName'])
                {
                    // found a known child node
                    continue 2;
                }
            }
            // if we end up here : the knownChildNode is missing in the data
            $this->childNodes[] = ['name' => $knownChildNodeName, 'data' => null];
        }


        // also report if we missed some ChildNode we are supposed to have processed
        $this->reportUnknownChildNodes($this->knownChildNodes, array_unique(array_column($allChildNodes,'name')));
    }

    public function __call(string $methodName , array $methodArguments ) : mixed
    {
        // get or set method?
        if (substr($methodName,0,3) == 'get')
        {
            $name = lcfirst(substr($methodName,3));
            // getter for a known attribute?
            foreach(array_keys($this->knownAttributes) as $attrName)
            {
                if ($attrName == $name)
                {
                    // this is a known attribute : return the value or null
                    return ($this->attributes[$attrName]??null);
                }
            }

            // getter for a known childNode?
            foreach(array_keys($this->knownChildNodes) as $knownChildNodeName)
            {
                if ($knownChildNodeName == $name)
                {
                    // this is a known childNode : return the object(s) or null
                    $returnresults = [];
                    foreach($this->childNodes as $childNode)
                    {
                        if ($childNode['name'] == $knownChildNodeName)
                        {
                            $returnresults[] = $childNode['data'];
                        }
                    }
                    if (count($returnresults) == 0)
                    {
                        // no match
                        return null;
                    }
                    elseif (count($returnresults) == 1)
                    {
                        // single results
                        return $returnresults[0];
                    }
                    else
                    {
                        // multiple objects
                        return $returnresults;
                    }
                }
            }

            // if we end up here : no match
        }
        elseif (substr($methodName,0,3) == 'set')
        {
            // do we have a set method with only 1 argument?
            if (count($methodArguments) == 1)
            {
                $name = lcfirst(substr($methodName,3));
                foreach(array_keys($this->knownAttributes) as $attrName)
                {
                    if ($attrName == $name)
                    {
                        // this is a known attribute : set it if input is valid
                        $this->validateAttributeValue($attrName, $methodName, $methodArguments[0]); // throws an exception on a validation failure

                        $this->attributes[$attrName] = $methodArguments[0];
                    }
                }
                foreach(array_keys($this->knownChildNodes) as $nodeName)
                {
                    if ($nodeName == $name)
                    {
                        // this is a known childNode : set it if input is valid
                        $this->validateChildNodeObject($nodeName, $methodName, $methodArguments[0]);
                        $this->childNodes[] = ['name' => $nodeName, 'data' => $methodArguments[0]];
                    }
                }
            }
       }

       // we could not process the method : return the standard error
       throw new BadMethodCallException("Unknown method ".$methodName);
    }

    protected function validateChildNodeObject(string $childNodeName, string $methodName, mixed $object): mixed
    {
        // does the child node exist
        if (isset($this->knownChildNodes[$childNodeName]))
        {
            // is the object the right type?
            if (get_class($object) != $this->knownChildNodes[$childNodeName]['type'])
            {
                $errMsg = $methodName." : expected an object ".$this->knownChildNodes[$childNodeName]['type']." but received an ".get_class($object)." object.";
                throw new Exception($errMsg);
            }
        }
        else
        {
            // wrong object type was given
            $errMsg = $methodName." tries to set an unknown child node '".$childNodeName."'";
            throw new Exception($errMsg);
        }
    }

    protected function validateAttributeValue(string $attrName, string $methodName, mixed $value): void
    {
        $errMsg = false;
        $attrDef = $this->knownAttributes[$attrName];
        $attrDefType = $attrDef['type'];
        if ($attrDefType == 'integer')
        {
            // integer
            if (!is_numeric($value))
            {
                $errMsg = $methodName." needs to provide and integer. ".var_export($value,1);
            }
        }
        elseif ($attrDefType == 'enum')
        {
            $enumType = $attrDef['enumType'];
            // enum
            if (isset($this->enumValidations[$enumType]))
            {
                if (!in_array($value,$this->enumValidations[$enumType]))
                {
                    $errMsg = "Unknown enum value '".$value."' for enumType '".$enumType."'. Please add it to the enumType values";
                }
            }
            else
            {
                $errMsg = "Missing enumType '".$enumType."' in this->enumValidations in PP2019Elements. Please add it at the top of the class";
            }
        }
        else
        {
            // unhandled type
        }

        // in case we have an error : throw an exception
        if ($errMsg !== false)
        {
            throw new Exception($errMsg);
        }
    }

    public function writeToXML(XMLWriter $objWriter): void
    {
        // start element
        $objWriter->startElement($this->namespacedElementName);
        // do we have namespaces?
        if ($this->namespaces != [])
        {
            foreach($this->namespaces as $namespace => $url)
            {
                $objWriter->writeAttribute('xmlns:'.$namespace, $url);
            }
        }

        // do we have attributes?
        if ($this->attributes != [])
        {
            foreach($this->attributes as $attrName => $attrValue)
            {
                if (is_null($attrValue)) { continue; }
                $objWriter->writeAttribute($this->knownAttributes[$attrName]['namespacedName'], $attrValue);
            }
        }

        // do we have child nodes?
        if ($this->childNodes != [])
        {
            foreach($this->childNodes as $childNode)
            {
                if (is_null($childNode['data'])) { continue; }
                $childNode['data']->writeToXML($objWriter);
            }
        }

        // end element
        $objWriter->endElement();
    }

}